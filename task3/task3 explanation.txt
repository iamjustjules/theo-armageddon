The primary reasons why the earlier version didn't work is because:
1. Incorrect ordering led to errors. Depends_on ensured conditions were met before resource creation
2. Misconfiguration in IP ranges. I reviewed other code to update modules, resources, and CIDR blocks correctly for peering.
3. Lack of modularity led to issues. Reviewing the logging and error messages provided insights into specific fixes using terraform registry and online code
4. Documentation review (https://cloud.google.com/architecture/building-internet-connectivity-for-private-vms#terraform) helped to gain insight on how to peer portions together correctly.

Here’s how this works:
- Data Flow: Variables are defined in “variables.tf” files and passed into resources or modules via the module's configuration in “.tf” files. Outputs generated by resources within a module are often made available to other modules or the root configuration.
- Execution Order: Terraform creates a dependency graph based on the resources' relationships and dependencies. For example, a VM instance might need to wait for its network and subnet to be created first, handled automatically by Terraform.
- Module Reusability: By encapsulating related resources in modules (like a VPC with its networking rules and VM instances), you can reuse this setup in different environments or projects by changing the input variables.
Interaction Between Root and Modules
Understanding the interaction between the root configuration and modules in Terraform can significantly streamline your infrastructure as code practices. Let’s dive deeper into how these components interact within your Terraform setup:
Root Configuration
The root configuration is essentially the entry point of your Terraform project. It's where you define provider settings, backends, required versions, and where you invoke modules. The root configuration can also include resource definitions, but in large projects, most resources are managed inside modules to keep the root clean and maintainable.
Modules
Modules in Terraform serve as containers for multiple resources that are logically grouped together. They enable you to organize, reuse, and encapsulate complex setups. Each module can have its own set of resources, variables, outputs, and even other modules, creating a hierarchical structure.

The interaction between the root configuration and modules occurs primarily through:
1. Module Invocation: From the root configuration, you invoke modules by specifying the module source and passing input variables required by the module. These variables are defined in the module’s “variables.tf” file and set in the module block at the root.
2. Variable Passing: Variables provide a way to customize modules each time they are used. The root configuration passes values to these variables, which influence how the resources within the module are configured.
3. Accessing Module Outputs: The root configuration can access outputs from modules to use these values in other parts of your Terraform configuration or other modules. This is how different modules often interconnect.
4. Providers and Modules: While providers can be configured within modules, it's a common practice to configure providers in the root configuration to ensure consistency across all modules and manage provider versions and settings centrally.
Practical Example of Module Interaction
- Peering Module: In your configuration, the peering module is used to set up network peering between America and Europe networks. It requires network IDs from both the America and Europe modules.
Here, the root configuration acts as a mediator that passes necessary outputs from the America and Europe modules into the Peering module as inputs. This kind of data flow typifies the modular approach in Terraform, allowing each module to be self-contained yet interdependent through well-defined interfaces.
The root configuration is used to orchestrate the deployment with modules with the necessary parameters stitching outputs together to form the system. Modules hold resources and configurations to be reusable across infrastructure. Each component provides flexibility, reusability, and data flow between modules and back to the user or other parts of the configuration.

